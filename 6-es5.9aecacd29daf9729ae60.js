(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{"N+Nw":function(e,t,o){"use strict";o.r(t);var r=o("CcnG"),n=function(){function e(){this.content=[{title:"",type:"paragraphs",data:["An object is an unordered list of primitive data types (and sometimes reference data types) that is stored as a series of name-value pairs. Each item in the list is called a\xa0property\xa0(functions are called\xa0methods).","Think of an object as a list that contains items, and each item (a property or a method) in the list is stored by a name-value pair. Property names can be a string or a number, but if the property name is a number, it has to be accessed with the bracket notation.","The Object constructor creates an object wrapper for the given value. If the value is null or undefined, it will create and return an empty object, otherwise, it will return an object of a Type that corresponds to the given value. If the value is an object already, it will return the value. When called in a non-constructor context, Object behaves identically to new Object()","Object.prototype - Allows the addition of properties to all objects of type Object. Nearly all objects in JavaScript are instances of Object; a typical object inherits properties (including methods) from Object.prototype, although these properties may be shadowed (a.k.a. overridden). However, an Object may be deliberately created for which this is not true (e.g. by Object.create(null)), or it may be altered so that this is no longer true (e.g. with Object.setPrototypeOf).","Changes to the Object prototype object are seen by all objects through prototype chaining, unless the properties and methods subject to those changes are overridden further along the prototype chain. This provides a very powerful although potentially dangerous mechanism to override or extend object behaviour."],subTitle:"",footerText:"",text:""},{title:"Reference Data Type and Primitive Data Types",type:"code",subTitle:"",text:"One of the main differences between reference data type and primitive data types is reference data type\u2019s value is stored as a reference, it is not stored directly on the variable, as a value, as the primitive data types are. For example:",data:['// the primitive data type String is stored as a value <br/> const person = "Kobe";<br/> const anotherPerson = person; <br/>person\xa0=\xa0"Bryant";\xa0//\xa0value\xa0of\xa0person\xa0changed<br/>console.log(anotherPerson);\xa0//\xa0Kobe<br/>console.log(person);\xa0//\xa0Bryant'],footerText:"It is worth noting that even though we changed\xa0person\xa0to \u201cBryant,\u201d the\xa0anotherPerson\xa0variable still retains the value that person had. Compare the primitive data saved-as-value demonstrated above with the save-as-reference for objects:"},{title:"",type:"code",subTitle:"",text:"",data:['const person =\xa0{\xa0name:\xa0"Kobe"\xa0};<br/> const anotherPerson = person; <br/>person\xa0=\xa0"Bryant";<br/>console.log(anotherPerson);\xa0//\xa0Bryant<br/>console.log(person);\xa0//\xa0Bryant'],footerText:"In this example, we copied the\xa0person\xa0object to\xa0anotherPerson, but because the value in person was stored as a reference and not an actual value, when we changed the person.name property to \u201cBryant\u201d the anotherPerson reflected the change because it never stored an actual copy of its own value of the person\u2019s properties, it only had a reference to it."},{title:"Object Data Properties Have Attributes",type:"paragraphs",data:["Each data property (object property that store data) has not only the name-value pair, but also 3 attributes (the three attributes are set to true by default):","\u2014 Configurable Attribute:\xa0Specifies whether the property can be deleted or changed.","\u2014 Enumerable:\xa0Specifies whether the property can be returned in a for/in loop.","\u2014 Writable:\xa0Specifies whether the property can be changed."],subTitle:"",footerText:"",text:""},{title:"Creating Objects",type:"paragraphs",data:["These are the common ways to create objects:"],subTitle:"",footerText:"",text:""},{title:"Object Literals",type:"code",subTitle:"",text:"The most common and, indeed, the easiest way to create \u201cobjects\u201d is with the object literal described here:",data:['// this is an empty object initialized using the object literal notation<br/>const myBooks\xa0=\xa0{};<br/> // this is an object with 4 items, again using object literal<br/>const mango\xa0=\xa0{<br/>&emsp;&emsp;color:\xa0"yellow",<br/>&emsp;&emsp;shape:\xa0"round",<br/>&emsp;&emsp;sweetness:\xa08,<br/>&emsp;&emsp;howSweetAmI: function ()\xa0{<br/>&emsp;&emsp;&emsp;&emsp;console.log("Hmm\xa0Hmm\xa0Good");<br/>&emsp;&emsp;}<br/> }'],footerText:""},{title:"Object Constructor",type:"code",subTitle:"",text:"The second most common way to create objects is with Object constructor. A constructor is a function used for initializing new objects, and you use the new keyword to call the constructor.",data:['const mango = new Object();<br/> mango.color\xa0=\xa0"yellow";<br/> mango.shape\xa0=\xa0"round";<br/> mango.sweetness\xa0=\xa08;<br/> mango.howSweetAmI\xa0= function () {<br/> \xa0\xa0\xa0\xa0console.log("Hmm\xa0Hmm\xa0Good");<br/> }'],footerText:"While you can use some reserved word such as \u201cfor\u201d as property names in your objects, it is wise to avoid this altogether. Objects can contain any other data type, including Numbers, Arrays, and even other Objects. Here are two common patterns for creating objects."},{title:"Object's create method:",type:"code",subTitle:"",text:"The create method of Object creates a new object by passing the prototype object as a parameter",data:["const object = Object.create(null);"],footerText:""},{title:"Function constructor",type:"code",subTitle:"",text:"Create any function and apply the new operator to create object instances",data:['function Person(name)\xa0{<br/> \xa0\xa0\xa0\xa0const\xa0object\xa0=\xa0{};<br/> \xa0\xa0\xa0\xa0object.name\xa0=\xa0name;<br/> \xa0\xa0\xa0\xa0object.age\xa0=\xa021;<br/> \xa0\xa0\xa0\xa0return\xa0object;<br/> }<br/> const object\xa0=\xa0new\xa0Person("user");'],footerText:""},{title:"Function constructor with prototype:",type:"code",subTitle:"",text:"This is similar to function constructor but it uses prototype for their properties and methods,",data:['function Person()\xa0{\xa0}<br/>Person.prototype.name\xa0=\xa0"user";<br/> const object\xa0=\xa0new\xa0Person();<br/> // This is equivalent to an instance created with an object create method with a function prototype and then call that function with an instance and parameters as arguments. <br/> function\xa0func()\xa0{\xa0};<br/> new\xa0func(x,\xa0y,\xa0z);<br/> // OR Create a new instance using function prototype.<br/> const newInstance\xa0=\xa0Object.create(func.prototype);<br/> // Call the function <br/> const result\xa0=\xa0func.call(newInstance,\xa0x,\xa0y,\xa0z); <br/> // If the result is a non-null object then use it otherwise just use the new instance. <br/> console.log(result\xa0&amp;&amp;\xa0typeof\xa0result\xa0===\xa0"object"\xa0?\xa0result\xa0:\xa0newInstance);'],footerText:""},{title:"ES6 Class syntax",type:"code",subTitle:"",text:"ES6 introduces class feature to create the objects",data:['class Person\xa0{<br/> \xa0\xa0\xa0 constructor(name)\xa0{<br/> \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0this.name\xa0=\xa0name;<br/> \xa0\xa0\xa0\xa0}<br/> }<br/> const object\xa0=\xa0new\xa0Person("Richard");'],footerText:""},{title:"Singleton pattern",type:"paragraphs",data:["A Singleton is an object which can only be instantiated one time. Repeated calls to its constructor return the same instance and this way one can ensure that they don't accidentally create multiple instances."],subTitle:"",footerText:"",text:""},{title:"How to Access Properties on an Object",type:"paragraphs",data:["The two primary ways of accessing properties of an object are with dot notation and bracket notation."],subTitle:"",footerText:"",text:""},{title:"Dot Notation",type:"code",subTitle:"",text:"",data:['const book\xa0=\xa0{\xa0title:\xa0"Ways\xa0to\xa0Go",\xa0pages:\xa050,\xa0bookMark1:\xa0"Page\xa020"\xa0};\xa0<br/> // to access the properties of the book object with dot notation, you do this:<br/> console.log\xa0(book.title);\xa0//\xa0Ways\xa0to\xa0Go\xa0<br/> console.log\xa0(book.pages);\xa0//\xa050'],footerText:""},{title:"Bracket Notation",type:"code",subTitle:"",text:"To access the properties of the book object with bracket notation, Accessing a property on an object that does not exist will result in\xa0undefined.",data:['console.log(book["title"]);\xa0//\xa0Ways\xa0to\xa0Go\xa0<br/> console.log(book["pages"]);\xa0//\xa050\xa0<br/> // or, in case you have the property name in a variable:<br/> const bookTitle\xa0=\xa0"title"; <br/> console.log(book[bookTitle]);\xa0//\xa0Ways\xa0to\xa0Go\xa0<br/> console.log(book["bookMark"\xa0+\xa01]);\xa0//\xa0Page\xa020'],footerText:""},{title:"Deleting Properties of an Object",type:"paragraphs",data:["To delete a property from an object, use the delete operator. Properties that were inherited cannot be deleted, nor did properties with their attributes set to configurable. You must delete the inherited properties on the prototype object (where the properties were defined). Also, you cannot delete properties of the global object, which were declared with the var keyword. The delete operator returns true if the delete was successful. And surprisingly, it also returns true if the property to delete was non-existent or the property could not be deleted (such as non-configurable or not owned by the object)."],subTitle:"",footerText:"",text:""},{title:"Serialize and Deserialize Objects",type:"paragraphs",data:["To transfer objects via HTTP or to otherwise convert it to a string, we need to serialize it (convert it to a string); JSON.stringify() is useful function to serialize your objects. To Deserialize object (convert it to an object from a string), use the JSON.parse() function."],subTitle:"",footerText:"",text:""},{title:"Methods of the Object constructor",type:"code",subTitle:"Object.assign()",text:"The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object. Properties in the target object will be overwritten by properties in the sources if they have the same key. It uses [[Get]] on the source and [[Set]] on the target, so it will invoke getters and setters. Therefore it assigns properties versus just copying or defining new properties. This may make it unsuitable for merging new properties into a prototype if the merge sources contain getters. For copying property definitions, including their enumerability, into prototypes Object.getOwnPropertyDescriptor() and Object.defineProperty() should be used instead. Both String and Symbol properties are copied. In case of an error, for example if a property is non-writable, a TypeError will be raised, and the target object can be changed if any properties are added before error is raised. Note that Object.assign() does not throw on null or undefined source values.",data:["// In Progress"],footerText:"Can use in: Cloning an object, Warning for Deep Clone, Merging objects, Merging objects with same properties, Copying symbol-typed properties, Properties on the prototype chain and non-enumerable properties cannot be copied, Primitives will be wrapped to objects, Exceptions will interrupt the ongoing copying task, Copying accessors"},{title:"",type:"code",subTitle:"Object.prototype.toLocaleString()",text:"The toLocaleString() method returns a string representing the object.This method is meant to be overridden by derived objects for locale - specific  purposes.Object's toLocaleString returns the result of calling toString(). This function is provided to give objects a generic toLocaleString method, even though not all may use it.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.prototype.toString()",text:'The toString() method returns a string representing the object. Every object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected.By default, the toString() method is inherited by every object descended from Object.If this method is not overridden in a custom object, toString() returns "[object type]", where type is the object type.',data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.keys()",text:"The Object.keys() method returns an array of a given object's own property names, in the same order as we get with a normal loop.Object.keys() returns an array whose elements are strings corresponding to the enumerable properties found directly upon object. The ordering of the properties is the same as that given by looping over the properties of the object manually.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.values()",text:"The Object.values() method returns an array of a given object's own enumerable property values, in the same order as that provided by a for...in loop(the difference being that a for-in loop enumerates properties in the prototype chain as well). Object instances and Object prototype object All objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden.For example, other constructors' prototypes override the constructor property and provide their own toString() methods.Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.prototype.valueOf()",text:"The valueOf() method returns the primitive value of the specified object.JavaScript calls the valueOf method to convert an object to a primitive value.You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.By default, the valueOf method is inherited by every object descended from Object.Every built-in core object overrides this method to return an appropriate value.If an object has no primitive value, valueOf returns the object itself.You can use valueOf within your own code to convert a built -in object into a primitive value.When you create a custom object, you can override Object.prototype.valueOf() to call a custom method instead of the default Object method.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.setPrototypeOf()",text:"The Object.setPrototypeOf() method sets the prototype (i.e., the internal [[Prototype]] property) of a specified object to another object or null. Throws a TypeError exception if the object whose [[Prototype]] is to be modified is non-extensible according to Object.isExtensible(). Does nothing if the prototype parameter isn't an object or null (i.e., number, string, boolean, or undefined). Otherwise, this method changes the [[Prototype]] of obj to the new value. Object.setPrototypeOf() is in the ECMAScript 2015 specification. It is generally considered the proper way to set the prototype of an object, vs. the more controversial Object.prototype.__proto__ property.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.prototype.constructor",text:'The constructor property returns a reference to the Object constructor function that created the instance object. Note that the value of this property is a reference to the function itself, not a string containing the function\'s name. The value is only read-only for primitive values such as 1, true and "test". All objects (with the exception of objects created with Object.create(null)) will have a constructor property. Objects created without the explicit use of a constructor function (i.e. the object and array literals) will have a constructor property that points to the Fundamental Object constructor type for that object.',data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.prototype.hasOwnProperty()",text:"The hasOwnProperty() method returns a boolean indicating whether the object has the specified property as its own property (as opposed to inheriting it). All descendents of Object inherit the hasOwnProperty method. This method can be used to determine whether an object has the specified property as a direct property of that object; unlike the in operator, this method does not check for a property in the object's prototype chain.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.prototype.isPrototypeOf()",text:"The isPrototypeOf() method allows to check whether or not an object exists within another object's prototype chain. Object.prototype.propertyIsEnumerable() - The propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable. Every object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.defineProperty()",text:"The static method Object.defineProperty() defines a new property directly on an object, or modifies an existing property on an object, and returns the object. This method allows a precise addition to or modification of a property on an object. Normal property addition through assignment creates properties which show up during property enumeration (for...in loop or Object.keys method), whose values may be changed, and which may be deleted. This method allows these extra details to be changed from their defaults. By default, values added using Object.defineProperty() are immutable. Property descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both. Both data and accessor descriptors are objects. They share the following optional keys: Configurable - true if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object. - Defaults to false. Enumerable - true if and only if this property shows up during enumeration of the properties on the corresponding object. - Defaults to false. A data descriptor also has the following optional keys: Value - The value associated with the property. Can be any valid JavaScript value (number, object, function, etc). - Defaults to undefined. Writable - true if and only if the value associated with the property may be changed with an assignment operator. - Defaults to false. An accessor descriptor also has the following optional keys: Get - A function which serves as a getter for the property, or undefined if there is no getter. When the property is accessed, this function is called without arguments and with this set to the object through which the property is accessed (this may not be the object on which the property is defined due to inheritance). The return value will be used as the value of the property. - Defaults to undefined. Set - A function which serves as a setter for the property, or undefined if there is no setter. When the property is assigned to, this function is called with one argument (the value being assigned to the property) and with this set to the object through which the property is assigned. - Defaults to undefined. If a descriptor has neither of value, writable, get and set keys, it is treated as a data descriptor. If a descriptor has both value or writable and get or set keys, an exception is thrown. Bear in mind that these attributes are not necessarily the descriptor's own properties. Inherited properties will be considered as well. In order to ensure these defaults are preserved, you might freeze the Object.prototype upfront, specify all options explicitly, or point to null with Object.create(null).",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.defineProperties()",text:"The Object.defineProperties() method defines new or modifies existing properties directly on an object, returning the object. - Object.defineProperties(obj, props) Obj - The object on which to define or modify properties. Props - An object whose own enumerable properties constitute descriptors for the properties to be defined or modified. Property descriptors present in objects come in two main flavors: data descriptors and accessor descriptors (see Object.defineProperty() for more details). Descriptors have the following keys: Configurable - true if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object. - Defaults to false. Enumerable - true if and only if this property shows up during enumeration of the properties on the corresponding object. - Defaults to false. Value - The value associated with the property. Can be any valid JavaScript value (number, object, function, etc). - Defaults to undefined. Writable - true if and only if the value associated with the property may be changed with an assignment operator. - Defaults to false. Get - A function which serves as a getter for the property, or undefined if there is no getter. The function's return value will be used as the value of the property. - Defaults to undefined. Set - A function which serves as a setter for the property, or undefined if there is no setter. The function will receive as its only argument the new value being assigned to the property. - Defaults to undefined. Object.defineProperties, in essence, defines all properties corresponding to the enumerable own properties of props on the object obj object.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.getOwnPropertyDescriptors()",text:"The Object.getOwnPropertyDescriptors() method returns all own property descriptors of a given object.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.getOwnPropertyNames()",text:"The Object.getOwnPropertyNames() method returns an array of all properties (including non-enumerable properties except for those which use Symbol)        found directly in a given object. Object.getOwnPropertyNames() returns an array whose elements are strings corresponding to the enumerable and non-enumerable properties found directly in a given object obj. The ordering of the enumerable properties in the array is consistent with the ordering exposed by a for...in loop (or by Object.keys()) over the properties of the object. The ordering of the non-enumerable properties in the array and the ordering among the enumerable properties is not defined.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.getOwnPropertySymbols()",text:"The Object.getOwnPropertySymbols() method returns an array of all symbol properties found directly upon a given object. Similar to Object.getOwnPropertyNames(), you can get all symbol properties of a given object as an array of symbols. Note that Object.getOwnPropertyNames() itself does not contain the symbol properties of an object and only the string properties. As all objects have no own symbol properties initially, Object.getOwnPropertySymbols() returns an empty array unless you have set symbol properties on your object.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.getPrototypeOf()",text:'The Object.getPrototypeOf() method returns the prototype (i.e. the value of the internal [[Prototype]] property) of the specified object. Object.is() - Object.is() determines whether two values are the same value. Two values are the same if one of the following holds: both undefined, both null, both true or both false, both strings of the same length with the same characters in the same order, both the same object, both numbers and both +0, both -0, both NaN, or both non-zero and both not NaN and both have the same value. This is not the same as being equal according to the == operator. The == operator applies various coercions to both sides (if they are not the same Type) before testing for equality (resulting in such behavior as "" == false being true), but Object.is doesn\'t coerce either value. This is also not the same as being equal according to the === operator. The === operator (and the == operator as well) treats the number values -0 and +0 as equal and treats Number.NaN as not equal to NaN.',data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.isExtensible()",text:"The Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it). Objects are extensible by default: they can have new properties added to them, and (in engines that support __proto__ their __proto__ property) can be modified. An object can be marked as non-extensible using Object.preventExtensions(), Object.seal(), or Object.freeze().",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.entries()",text:"The Object.entries() method returns an array of a given object's own enumerable property [key, value] pairs, in the same order as that provided by a for...in loop (the        difference being that a for-in loop enumerates properties in the prototype chain as well). The order of the array returned by Object.entries() does not depend on how an object is defined. If there is a need for certain ordering then the array needs to be sorted first like Object.entries(obj).sort((a, b) =&gt; a[0] - b[0]);. Object.entries() returns an array whose elements are arrays corresponding to the enumerable property [key, value] pairs found directly upon object. The ordering of the properties is the same as that given by looping over the property values of the object manually.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.freeze()",text:"The Object.freeze() method freezes an object. A frozen object can no longer be changed; freezing an object prevents new properties from being added to it, existing properties from being removed, prevents changing the enumerability, configurability, or writability of existing properties, and prevents the values of existing properties from being changed. In addition, freezing an object also prevents its prototype from being changed. freeze() returns the same object that was passed in. Nothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail, either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode). For data properties of a frozen object, values cannot be changed, the writable and configurable attributes are set to false. Accessor properties (getters and setters) work the same (and still give the illusion that you are changing the value). Note that values that are objects can still be modified, unless they are also frozen. As an object, an array can be frozen; after doing so, its        elements cannot be altered and no elements can be added to or removed from the array. freeze() returns the same object that was passed into the function. It does not create a frozen copy.The object being frozen is immutable. However, it is not necessarily constant. The following example shows that a frozen object is not constant (freeze is shallow). To be a constant object, the entire reference graph (direct and indirect references to other objects) must reference only immutable frozen objects. The object being frozen is said to be immutable because the entire object state (values and references to other objects) within the whole object is fixed. Note that strings, numbers, and booleans are always immutable and that Functions and Arrays are objects.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:'What is "shallow freeze"?',text:"The result of calling Object.freeze(object) only applies to the immediate properties of object itself and will prevent future property addition, removal or value re-assignment operations only on object. If the value of those properties are objects themselves, those objects are not frozen and may be the target of property addition, removal or value re-assignment operations. ",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.fromEntries()",text:"The Object.fromEntries() method takes a list of key-value pairs and returns a new object whose properties are given by those entries. The iterable argument is expected to be an object that implements an @@iterator method, that returns an iterator object, that produces a two element array-like object, whose first element is a value that will be used as a property key, and whose second element is the value to associate with that property key. Object.fromEntries() performs the reverse of Object.entries().",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.getOwnPropertyDescriptor()",text:"The Object.getOwnPropertyDescriptor() method returns a property descriptor for an own property (that is, one directly present on an object and not in the object's prototype chain) of a given object. Object.isFrozen() - The Object.isFrozen() determines if an object is frozen. An object is frozen if and only if it is not extensible, all its properties are non-configurable, and all its data properties (that is, properties which are not accessor properties with getter or setter components) are non-writable.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.isSealed()",text:"The Object.isSealed() method determines if an object is sealed. Returns true if the object is sealed, otherwise false. An object is sealed if it is not extensible and if all its properties are non-configurable and therefore not removable (but not necessarily non-writable).",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.preventExtensions()",text:"The Object.preventExtensions() method prevents new properties from ever being added to an object (i.e. prevents future extensions to the object). An object is extensible if new properties can be added to it. Object.preventExtensions() marks an object as no longer extensible, so that it will never have properties beyond the ones it had at the time it was marked as non-extensible. Note that the properties of a non-extensible object, in general, may still be deleted. Attempting to add new properties to a non-extensible object will fail, either silently or by throwing a TypeError (most commonly, but not exclusively, when in strict mode). Object.preventExtensions() only prevents addition of own properties. Properties can still be added to the object prototype. This method makes the [[prototype]] of the target immutable; any [[prototype]] re-assignment will throw a TypeError. This behavior is specific to the internal [[prototype]] property, other properties of the target object will remain mutable. There is no way to make an object extensible again once it has been made non-extensible.",data:["// In Progress"],footerText:""},{title:"",type:"code",subTitle:"Object.seal()",text:"The Object.seal() method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable. By default, objects are extensible (new properties can be added to them). Sealing an object prevents new properties from being added and marks all existing properties as non-configurable. This has the effect of making the set of properties on the object fixed and immutable. Making all properties non-configurable also prevents them from being converted from data properties to accessor properties and vice versa, but it does not prevent the values of data properties from being changed. Attempting to delete or add properties to a sealed object, or to convert a data property to accessor or vice versa, will fail, either silently or by throwing a TypeError (most commonly, although not exclusively, when in strict mode code). The prototype chain remains untouched. However, the __proto__ property is sealed as well. Returns a reference to the passed object. Existing properties in objects frozen with Object.freeze() are made immutable. Objects sealed with Object.seal() can have their existing properties changed.",data:["// In Progress"],footerText:""}]}return e.ngInjectableDef=r.Fb({factory:function(){return new e},token:e,providedIn:"root"}),e}(),a=function(){function e(e){this.objectService=e,this.pageTitle="Objects"}return e.prototype.ngOnInit=function(){this.content=this.objectService.content},e}(),i=function(){return function(){}}(),s=o("pMnS"),l=o("21Lb"),c=o("OzfB"),p=o("Fzqc"),u=o("Ip0R"),h=o("8ef6"),b=o("XpDt"),d=o("WHjn"),f=o("nlns"),y=o("57tH"),m=o("C/7A"),g=o("toH5"),j=o("uilG"),w=o("aLe/"),v=o("Ln9c"),x=o("dJpi"),T=r.nb({encapsulation:2,styles:[],data:{}});function O(e){return r.Db(0,[(e()(),r.pb(0,0,null,null,1,"h3",[],null,null,null,null,null)),(e()(),r.Cb(1,null,["",""]))],null,function(e,t){e(t,1,0,null==t.parent.parent.context.$implicit?null:t.parent.parent.context.$implicit.title)})}function P(e){return r.Db(0,[(e()(),r.pb(0,0,null,null,1,"div",[],null,null,null,null,null)),(e()(),r.Cb(1,null,[" "," "]))],null,function(e,t){e(t,1,0,t.context.$implicit)})}function k(e){return r.Db(0,[(e()(),r.pb(0,0,null,null,6,"article",[["fxLayout","column"],["fxLayoutGap","10px"]],null,null,null,null,null)),r.ob(1,671744,null,0,l.c,[r.k,c.i,[2,l.k],c.f],{fxLayout:[0,"fxLayout"]},null),r.ob(2,1720320,null,0,l.d,[r.k,r.z,p.b,c.i,[2,l.j],c.f],{fxLayoutGap:[0,"fxLayoutGap"]},null),(e()(),r.eb(16777216,null,null,1,null,O)),r.ob(4,16384,null,0,u.j,[r.O,r.L],{ngIf:[0,"ngIf"]},null),(e()(),r.eb(16777216,null,null,1,null,P)),r.ob(6,278528,null,0,u.i,[r.O,r.L,r.s],{ngForOf:[0,"ngForOf"]},null)],function(e,t){e(t,1,0,"column"),e(t,2,0,"10px"),e(t,4,0,null==t.parent.context.$implicit?null:t.parent.context.$implicit.title),e(t,6,0,null==t.parent.context.$implicit?null:t.parent.context.$implicit.data)},null)}function I(e){return r.Db(0,[(e()(),r.pb(0,0,null,null,2,"app-code-view",[["fxLayout","row"]],null,null,null,h.b,h.a)),r.ob(1,671744,null,0,l.c,[r.k,c.i,[2,l.k],c.f],{fxLayout:[0,"fxLayout"]},null),r.ob(2,638976,null,0,b.a,[],{content:[0,"content"]},null)],function(e,t){e(t,1,0,"row"),e(t,2,0,t.parent.context.$implicit)},null)}function L(e){return r.Db(0,[(e()(),r.pb(0,0,null,null,1,"app-list-view",[],null,null,null,d.b,d.a)),r.ob(1,114688,null,0,f.a,[],{content:[0,"content"]},null)],function(e,t){e(t,1,0,t.parent.context.$implicit)},null)}function z(e){return r.Db(0,[(e()(),r.pb(0,0,null,null,8,"div",[["fxLayout","column"],["fxLayoutGap","10px"]],[[8,"id",0]],null,null,null,null)),r.ob(1,671744,null,0,l.c,[r.k,c.i,[2,l.k],c.f],{fxLayout:[0,"fxLayout"]},null),r.ob(2,1720320,null,0,l.d,[r.k,r.z,p.b,c.i,[2,l.j],c.f],{fxLayoutGap:[0,"fxLayoutGap"]},null),(e()(),r.eb(16777216,null,null,1,null,k)),r.ob(4,16384,null,0,u.j,[r.O,r.L],{ngIf:[0,"ngIf"]},null),(e()(),r.eb(16777216,null,null,1,null,I)),r.ob(6,16384,null,0,u.j,[r.O,r.L],{ngIf:[0,"ngIf"]},null),(e()(),r.eb(16777216,null,null,1,null,L)),r.ob(8,16384,null,0,u.j,[r.O,r.L],{ngIf:[0,"ngIf"]},null)],function(e,t){e(t,1,0,"column"),e(t,2,0,"10px"),e(t,4,0,"paragraphs"===(null==t.context.$implicit?null:t.context.$implicit.type)),e(t,6,0,"code"===(null==t.context.$implicit?null:t.context.$implicit.type)),e(t,8,0,"list"===(null==t.context.$implicit?null:t.context.$implicit.type))},function(e,t){e(t,0,0,null==t.context.$implicit?null:t.context.$implicit.title)})}function S(e){return r.Db(0,[(e()(),r.pb(0,0,null,null,26,"div",[["class","main-page"],["fxLayout","column"]],null,null,null,null,null)),r.ob(1,671744,null,0,l.c,[r.k,c.i,[2,l.k],c.f],{fxLayout:[0,"fxLayout"]},null),(e()(),r.pb(2,0,null,null,4,"app-top-menu",[["fxFlex","80px"],["fxLayout","row"],["fxLayoutAlign","space-between center"]],null,null,null,y.b,y.a)),r.ob(3,671744,null,0,l.c,[r.k,c.i,[2,l.k],c.f],{fxLayout:[0,"fxLayout"]},null),r.ob(4,671744,null,0,l.b,[r.k,c.i,[2,l.i],c.f],{fxLayoutAlign:[0,"fxLayoutAlign"]},null),r.ob(5,671744,null,0,l.a,[r.k,c.i,c.e,l.h,c.f],{fxFlex:[0,"fxFlex"]},null),r.ob(6,114688,null,0,m.a,[g.a],null,null),(e()(),r.pb(7,0,null,null,19,"div",[["class","main-content"],["fxFlex","100%"],["fxLayout","row"],["fxLayoutGap","20px"]],null,null,null,null,null)),r.ob(8,671744,null,0,l.c,[r.k,c.i,[2,l.k],c.f],{fxLayout:[0,"fxLayout"]},null),r.ob(9,1720320,null,0,l.d,[r.k,r.z,p.b,c.i,[2,l.j],c.f],{fxLayoutGap:[0,"fxLayoutGap"]},null),r.ob(10,671744,null,0,l.a,[r.k,c.i,c.e,l.h,c.f],{fxFlex:[0,"fxFlex"]},null),(e()(),r.pb(11,0,null,null,12,"section",[["fxFlex","70%"],["fxLayout","column"],["fxLayoutGap","16px"]],null,null,null,null,null)),r.ob(12,671744,null,0,l.c,[r.k,c.i,[2,l.k],c.f],{fxLayout:[0,"fxLayout"]},null),r.ob(13,1720320,null,0,l.d,[r.k,r.z,p.b,c.i,[2,l.j],c.f],{fxLayoutGap:[0,"fxLayoutGap"]},null),r.ob(14,671744,null,0,l.a,[r.k,c.i,c.e,l.h,c.f],{fxFlex:[0,"fxFlex"]},null),(e()(),r.pb(15,0,null,null,1,"h2",[],null,null,null,null,null)),(e()(),r.Cb(16,null,["",""])),(e()(),r.pb(17,0,null,null,6,"perfect-scrollbar",[],[[2,"ps-show-limits",null],[2,"ps-show-active",null]],null,null,j.b,j.a)),r.ob(18,507904,null,0,w.b,[r.z,r.h,r.B],null,null),(e()(),r.pb(19,0,null,0,4,"div",[["fxLayout","column"],["fxLayoutGap","16px"]],null,null,null,null,null)),r.ob(20,671744,null,0,l.c,[r.k,c.i,[2,l.k],c.f],{fxLayout:[0,"fxLayout"]},null),r.ob(21,1720320,null,0,l.d,[r.k,r.z,p.b,c.i,[2,l.j],c.f],{fxLayoutGap:[0,"fxLayoutGap"]},null),(e()(),r.eb(16777216,null,null,1,null,z)),r.ob(23,278528,null,0,u.i,[r.O,r.L,r.s],{ngForOf:[0,"ngForOf"]},null),(e()(),r.pb(24,0,null,null,2,"app-aside-summary",[["fxFlex","30%"]],null,null,null,v.b,v.a)),r.ob(25,671744,null,0,l.a,[r.k,c.i,c.e,l.h,c.f],{fxFlex:[0,"fxFlex"]},null),r.ob(26,114688,null,0,x.a,[g.a],{content:[0,"content"],pagePath:[1,"pagePath"]},null)],function(e,t){var o=t.component;e(t,1,0,"column"),e(t,3,0,"row"),e(t,4,0,"space-between center"),e(t,5,0,"80px"),e(t,6,0),e(t,8,0,"row"),e(t,9,0,"20px"),e(t,10,0,"100%"),e(t,12,0,"column"),e(t,13,0,"16px"),e(t,14,0,"70%"),e(t,18,0),e(t,20,0,"column"),e(t,21,0,"16px"),e(t,23,0,o.content),e(t,25,0,"30%"),e(t,26,0,o.content,"objects")},function(e,t){e(t,16,0,t.component.pageTitle),e(t,17,0,r.yb(t,18).autoPropagation,r.yb(t,18).scrollIndicators)})}function A(e){return r.Db(0,[(e()(),r.pb(0,0,null,null,1,"app-objects",[],null,null,null,S,T)),r.ob(1,114688,null,0,a,[n],null,null)],function(e,t){e(t,1,0)},null)}var D=r.lb("app-objects",a,A,{},{},[]),E=o("hUWP"),N=o("3pJQ"),F=o("V9q+"),C=o("FpXt"),G=o("ZYCi");o.d(t,"ObjectsModuleNgFactory",function(){return B});var B=r.mb(i,[],function(e){return r.vb([r.wb(512,r.j,r.Z,[[8,[s.a,D]],[3,r.j],r.x]),r.wb(4608,u.l,u.k,[r.u,[2,u.x]]),r.wb(5120,r.b,function(e,t){return[c.j(e,t)]},[u.c,r.B]),r.wb(4608,g.a,g.a,[]),r.wb(4608,n,n,[]),r.wb(1073742336,u.b,u.b,[]),r.wb(1073742336,c.c,c.c,[]),r.wb(1073742336,p.a,p.a,[]),r.wb(1073742336,l.g,l.g,[]),r.wb(1073742336,E.b,E.b,[]),r.wb(1073742336,N.a,N.a,[]),r.wb(1073742336,F.a,F.a,[[2,c.g],r.B]),r.wb(1073742336,w.d,w.d,[]),r.wb(1073742336,C.a,C.a,[]),r.wb(1073742336,G.l,G.l,[[2,G.q],[2,G.k]]),r.wb(1073742336,i,i,[]),r.wb(256,w.a,C.b,[]),r.wb(1024,G.i,function(){return[[{path:"",component:a}]]},[])])})}}]);